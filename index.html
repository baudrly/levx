<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chromosome Levenshtein distance matrix calculator</title> 
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js" charset="utf-8"></script>
    <link rel="icon" type="image/png" href="favicon.ico">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header class="container-fluid">
        <h1>Chromosome Pairwise Distance Matrix</h1>
    </header>

    <main class="container">
        <section class="section input-methods-section">
            <h2>Input FASTA Data</h2>
            <div class="tabs">
                <button class="tab-button active" data-tab="fileTab">Upload File</button>
                <button class="tab-button" data-tab="urlTab">Fetch from URL</button>
                <button class="tab-button" data-tab="pasteTab">Paste Text</button>
                <button class="tab-button" data-tab="exampleTab">Use Example</button>
            </div>

            <div id="fileTab" class="tab-content active">
                <div class="input-group">
                    <label for="fastaFile">Select FASTA File (.fa, .fasta, .fa.gz, .fasta.gz):</label>
                    <input type="file" id="fastaFile" accept=".fa,.fasta,.fa.gz,.fasta.gz">
                </div>
            </div>
            <div id="urlTab" class="tab-content">
                <div class="input-group">
                    <label for="fastaUrl">Enter FASTA File URL (plain or .gz):</label>
                    <input type="url" id="fastaUrl" placeholder="https://example.com/sequence.fasta.gz">
                </div>
                <button id="fetchUrlButton" class="input-action-button">Fetch and Stage Data</button>
            </div>
            <div id="pasteTab" class="tab-content">
                <div class="input-group">
                    <label for="fastaTextArea">Paste FASTA content here:</label>
                    <textarea id="fastaTextArea" rows="10" placeholder=">Seq1_header
ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT
>Seq2_another_header
CGTACGTACGTACGTACGTACGTACGTACGTACGTACGAT"></textarea>
                </div>
                 <div class="checkbox-group input-group">
                    <input type="checkbox" id="pasteIsGzipped" disabled> 
                    <label for="pasteIsGzipped">Pasted content is Gzipped (advanced)</label>
                </div>
                <button id="pasteButton" class="input-action-button">Stage Pasted Text</button>
            </div>
            <div id="exampleTab" class="tab-content">
                <div class="input-group">
                    <label for="exampleSelect">Choose an example:</label>
                    <select id="exampleSelect">
                        <option value="small_distinct">Small Distinct (2 seqs, ~30bp)</option>
                        <option value="medium_similar">Medium Similar (3 seqs, ~60bp)</option>
                    </select>
                </div>
                <button id="loadExampleButton" class="input-action-button">Load Example & Visualize</button>
            </div>
        </section>

        <section class="section action-section">
            <h2>Actions on Staged Data</h2>
            <p><em>Data must be staged via one of the methods above before these actions are available.</em></p>
            <div class="button-group">
                <button id="visualizeButton" disabled>Visualize Staged Data (Plot)</button>
                <button id="downloadIpcButton" disabled>Download Full Data (Arrow IPC)</button>
            </div>
            <div class="input-group">
                <label for="ipcFileName">IPC Filename (for download):</label>
                <input type="text" id="ipcFileName" value="distances.ipc">
            </div>
        </section>

        <section class="section plot-section hidden" id="plotArea">
            <h2>Distance Matrix Visualization</h2>
            <div class="input-group">
                <label for="chromosomeSelect">Select Chromosome to Visualize:</label>
                <select id="chromosomeSelect" disabled></select>
            </div>
            
            <div class="plot-controls">
                <div>
                    <label for="colorscaleSelect">Color Scale:</label>
                    <select id="colorscaleSelect">
                        <option value="Blues" selected>Blues</option> <option value="Greys">Greys</option>
                        <option value="Viridis">Viridis</option> <option value="Plasma">Plasma</option>
                        <option value="YlGnBu">YlGnBu</option> <option value="RdBu">Red-Blue</option>
                        <option value="Jet">Jet</option> <option value="Hot">Hot</option>
                        <option value="Electric">Electric</option> <option value="Earth">Earth</option>
                        <option value="Greens">Greens</option><option value="Reds">Reds</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showColorbar" checked>
                    <label for="showColorbar">Show Colorbar</label>
                </div>
                 <div class="checkbox-group">
                    <input type="checkbox" id="reverseColorscale">
                    <label for="reverseColorscale">Reverse Colorscale</label>
                </div>
                <div>
                    <label for="zminInput">Min Distance (zmin):</label>
                    <input type="number" id="zminInput" placeholder="auto" step="any">
                </div>
                 <div>
                    <label for="zmaxInput">Max Distance (zmax):</label>
                    <input type="number" id="zmaxInput" placeholder="auto" step="any">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="transposeMatrix">
                    <label for="transposeMatrix">Transpose Matrix (Swap X/Y)</label>
                </div>
                <div>
                    <label for="cellGapRange">Cell Gap: <span id="cellGapValue">0.5</span></label>
                    <input type="range" id="cellGapRange" min="0" max="5" step="0.1" value="0.5">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showTextOnCells">
                    <label for="showTextOnCells">Show Text on Cells (Slow for large plots)</label>
                </div>
                 <div class="checkbox-group">
                    <input type="checkbox" id="fixedAspectRatio" checked>
                    <label for="fixedAspectRatio">Fixed Aspect Ratio (Square Cells)</label>
                </div>
            </div>
            <div id="plotContainer">Plot will appear here after processing. Select a chromosome.</div>
        </section>

        <section class="section status-section">
            <h2>Processing Log</h2>
            <div id="spinnerContainer" class="spinner-container hidden">
                 <div class="spinner"></div>
            </div>
            <div id="status">Select a FASTA input method or file...</div>
        </section>
    </main>
    
    <footer class="container-fluid">

    </footer>

    <script type="module">
        import init, { process_fasta_to_plot_json, process_fasta_to_ipc_bytes } from './pkg/chromosome_distance_calculator.js';

        let wasmInitialized = false;
        let transformedPlotDataCache = null; 
        let currentFastaBytes = null; 
        let currentIsGzipped = false;
        
        // DOM Element Selection
        let fastaFileInput, fastaUrlInput, fetchUrlButton, fastaTextArea, pasteIsGzippedCheckbox, pasteButton,
            exampleSelect, loadExampleButton, visualizeButton, downloadIpcButton, ipcFileNameInput,
            statusDiv, spinnerContainer, plotArea, plotContainer, chromosomeSelect,
            colorscaleSelect, showColorbarCheckbox, reverseColorscaleCheckbox, zminInput, zmaxInput,
            transposeMatrixCheckbox, cellGapRange, cellGapValueSpan, showTextOnCellsCheckbox, fixedAspectRatioCheckbox; // New plot controls

        const GRID_SPACING_JS = 1000; 

        function initializeDOMReferences() {
            fastaFileInput = document.getElementById('fastaFile');
            fastaUrlInput = document.getElementById('fastaUrl');
            fetchUrlButton = document.getElementById('fetchUrlButton');
            fastaTextArea = document.getElementById('fastaTextArea');
            pasteIsGzippedCheckbox = document.getElementById('pasteIsGzipped');
            pasteButton = document.getElementById('pasteButton');
            exampleSelect = document.getElementById('exampleSelect');
            loadExampleButton = document.getElementById('loadExampleButton');
            visualizeButton = document.getElementById('visualizeButton');
            downloadIpcButton = document.getElementById('downloadIpcButton');
            ipcFileNameInput = document.getElementById('ipcFileName');
            statusDiv = document.getElementById('status');
            spinnerContainer = document.getElementById('spinnerContainer');
            plotArea = document.getElementById('plotArea');
            plotContainer = document.getElementById('plotContainer');
            chromosomeSelect = document.getElementById('chromosomeSelect');
            colorscaleSelect = document.getElementById('colorscaleSelect');
            showColorbarCheckbox = document.getElementById('showColorbar'); 
            reverseColorscaleCheckbox = document.getElementById('reverseColorscale'); 
            zminInput = document.getElementById('zminInput'); 
            zmaxInput = document.getElementById('zmaxInput'); 
            transposeMatrixCheckbox = document.getElementById('transposeMatrix');
            cellGapRange = document.getElementById('cellGapRange');
            cellGapValueSpan = document.getElementById('cellGapValue');
            showTextOnCellsCheckbox = document.getElementById('showTextOnCells');
            fixedAspectRatioCheckbox = document.getElementById('fixedAspectRatio');
        }
        
        // Utility Functions
        function logStatus(message) { /* ... same ... */ 
            console.log(message); 
            const timestamp = new Date().toLocaleTimeString();
            statusDiv.innerHTML += `[${timestamp}] ${message}\n`;
            statusDiv.scrollTop = statusDiv.scrollHeight; 
        }
        const rustProgressCallback = (message) => { logStatus(String(message)); };

        async function initializeWasm() { /* ... same ... */ 
            if (wasmInitialized) return true;
            try {
                logStatus("Initializing Rust Wasm module..."); await init(); wasmInitialized = true;
                logStatus("Rust Wasm module initialized successfully."); return true;
            } catch (e) {
                logStatus(`Error initializing Wasm: ${e.message || e}`); console.error("Wasm Init Error:", e);
                alert("Failed to initialize WebAssembly module. Check console for details."); return false;
            }
        }

        function updateActionButtonsState() { /* ... same ... */
            const dataReady = currentFastaBytes && currentFastaBytes.length > 0;
            if(visualizeButton) visualizeButton.disabled = !dataReady;
            if(downloadIpcButton) downloadIpcButton.disabled = !dataReady;
        }

        function setUIDisabledState(disabled) { /* ... same ... */
            if(fastaFileInput) fastaFileInput.disabled = disabled;
            if(fastaUrlInput) fastaUrlInput.disabled = disabled;
            if(fetchUrlButton) fetchUrlButton.disabled = disabled;
            if(fastaTextArea) fastaTextArea.disabled = disabled;
            if(pasteButton) pasteButton.disabled = disabled;
            if(exampleSelect) exampleSelect.disabled = disabled;
            if(loadExampleButton) loadExampleButton.disabled = disabled;
            if (disabled) { if(visualizeButton) visualizeButton.disabled = true; if(downloadIpcButton) downloadIpcButton.disabled = true; } 
            else { updateActionButtonsState(); }
        }

        // Data Loading Logic
        async function stageFastaFromFile(file) { /* ... same ... */
            if (!file) return; logStatus(`Staging file: ${file.name}`); currentIsGzipped = file.name.endsWith('.gz');
            try {
                const arrayBuffer = await file.arrayBuffer(); currentFastaBytes = new Uint8Array(arrayBuffer);
                logStatus(`File "${file.name}" staged (${(currentFastaBytes.length/1024).toFixed(2)} KB).`); updateActionButtonsState();
            } catch (e) { logStatus(`Error reading file: ${e.message || e}`); currentFastaBytes = null; updateActionButtonsState(); }
        }
        async function stageFastaFromUrl() { /* ... same ... */
            const url = fastaUrlInput.value.trim(); if (!url) { logStatus("Please enter a URL."); return; }
            logStatus(`Fetching FASTA from URL: ${url}`); spinnerContainer.classList.remove('hidden'); setUIDisabledState(true);
            try {
                const response = await fetch(url); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer(); currentFastaBytes = new Uint8Array(arrayBuffer);
                currentIsGzipped = url.endsWith('.gz');
                logStatus(`FASTA from URL staged (${(currentFastaBytes.length/1024).toFixed(2)} KB).`); updateActionButtonsState();
            } catch (e) { logStatus(`Error fetching from URL: ${e.message || e}`); currentFastaBytes = null; updateActionButtonsState(); }
            finally { spinnerContainer.classList.add('hidden'); setUIDisabledState(false); }
        }
        function stageFastaFromText() { /* ... same ... */
            const text = fastaTextArea.value; if (!text.trim()) { logStatus("Text area is empty."); return; }
            logStatus("Staging FASTA from pasted text..."); currentIsGzipped = pasteIsGzippedCheckbox.checked;
            if (currentIsGzipped) { logStatus("Warning: Gzipped pasted content unsupported. Treating as plain text."); currentIsGzipped = false; pasteIsGzippedCheckbox.checked = false; }
            const encoder = new TextEncoder(); currentFastaBytes = encoder.encode(text);
            logStatus(`Pasted text staged as FASTA (${(currentFastaBytes.length/1024).toFixed(2)} KB).`); updateActionButtonsState();
        }
        
        // --- Updated Example Data ---
        const exampleFastaData = {
            small_distinct: {
                name: "Small Distinct (2 seqs, ~30bp)", gzipped: false,
                content: `>SeqA_example_small_distinct
ACGTACGTACGTACGTACGTACGTACGTNN
>SeqB_example_small_distinct
TTTTCCCCAAAAGGGGTTTTCCCCAAAAGN`
            },
            medium_similar: {
                name: "Medium Similar (3 seqs, ~60bp)", gzipped: false,
                content: `>ChrOne_medium_similar_example_sequence_id_with_more_details
ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTNNNN
ACGTACGTACGTACGTACGTACGT
>ChrTwo_medium_similar_example_with_slight_variation_sequence
ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGGNNNN
ACGTACGTACGTACGTACGTACGT
>ChrThree_medium_similar_another_variation_of_sequence
ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTNNNN
AGGTACGTACGTACGTACGTACGA`
            }
        };
        async function stageAndProcessExample() { // Modified to call handleProcessingRequest
            const exampleKey = exampleSelect.value; const example = exampleFastaData[exampleKey]; if (!example) return;
            logStatus(`Loading example: "${example.name}"`); const encoder = new TextEncoder();
            currentFastaBytes = encoder.encode(example.content); currentIsGzipped = example.gzipped;
            logStatus(`Example "${example.name}" loaded and staged.`);
            updateActionButtonsState();
            await handleProcessingRequest(true); // Automatically trigger visualization
        }

        // --- Plotting Logic ---
        function transformJsonToHeatmapCache(jsonDataArray) { /* ... same as before ... */
            logStatus("Transforming JSON data for plotting..."); const cache = {};
            if (!jsonDataArray || !Array.isArray(jsonDataArray)) { logStatus("Error: Wasm did not return valid JSON array."); return null; }
            jsonDataArray.forEach(chromData => {
                if (!chromData || !chromData.name || !chromData.points || typeof chromData.max_idx === 'undefined') { logStatus(`Warning: Skipping malformed chromData.`); return; }
                const matrixSize = chromData.max_idx + 1;
                const xyIndices = Array.from({length: matrixSize}, (_, i) => i); 
                const zMatrix = Array(matrixSize).fill(null).map(() => Array(matrixSize).fill(NaN));
                chromData.points.forEach(p => {
                    if (p.x < matrixSize && p.y < matrixSize) { zMatrix[p.y][p.x] = p.d; zMatrix[p.x][p.y] = p.d; }
                });
                cache[chromData.name] = {
                    x: xyIndices.map(val => (val * GRID_SPACING_JS) / 1000), 
                    y: xyIndices.map(val => (val * GRID_SPACING_JS) / 1000), 
                    z: zMatrix, type: 'heatmap', name: chromData.name,
                    hoverongaps: false, 
                    colorbar: { title: 'Distance', titleside: 'right', tickfont: {size: 10} }
                };
            });
            logStatus("Data transformed for plotting."); return cache;
        }
        
        function updatePlot() {
            if (plotArea.classList.contains('hidden')) return; 
            if (!transformedPlotDataCache) { plotContainer.innerHTML = "No data. Process FASTA & 'Visualize'."; return; }
            const selectedChromName = chromosomeSelect.value;
            if (!selectedChromName || !transformedPlotDataCache[selectedChromName]) { plotContainer.innerHTML = `Plot data not found for ${selectedChromName}.`; return; }
            
            let plotTrace = JSON.parse(JSON.stringify(transformedPlotDataCache[selectedChromName])); // Deep copy for modification

            if (!plotTrace.x || plotTrace.x.length === 0) { plotContainer.innerHTML = `Data for ${selectedChromName} is empty.`; return; }

            // Apply plot options
            plotTrace.colorscale = colorscaleSelect.value; 
            plotTrace.showscale = showColorbarCheckbox.checked; 
            plotTrace.reversescale = reverseColorscaleCheckbox.checked; 
            plotTrace.xgap = parseFloat(cellGapRange.value);
            plotTrace.ygap = parseFloat(cellGapRange.value);

            if (showTextOnCellsCheckbox.checked) {
                // Prepare text array for Plotly (same dimensions as z)
                plotTrace.text = plotTrace.z.map(row => row.map(val => (isNaN(val) || val === null) ? '' : val.toString()));
                plotTrace.textfont = { size: 8, color: 'grey' }; // Adjust as needed
                plotTrace.hoverinfo = 'x+y+z'; // Show x, y, z on hover if text is shown
            } else {
                delete plotTrace.text; // Remove text if not showing
                plotTrace.hoverinfo = 'x+y+z';
            }

            if (transposeMatrixCheckbox.checked) {
                // Swap x and y data, and transpose z
                let tempX = plotTrace.x;
                plotTrace.x = plotTrace.y;
                plotTrace.y = tempX;
                plotTrace.z = plotTrace.z[0].map((_, colIndex) => plotTrace.z.map(row => row[colIndex]));
                if (plotTrace.text) { // Transpose text array as well
                     plotTrace.text = plotTrace.text[0].map((_, colIndex) => plotTrace.text.map(row => row[colIndex]));
                }
            }
            
            const data = [plotTrace]; 
            const zminUser = parseFloat(zminInput.value); const zmaxUser = parseFloat(zmaxInput.value);
            const makeDt_Tick = (axisData) => {
                if (!axisData || axisData.length === 0) return 100;
                const maxVal = axisData[axisData.length -1]; // Assumes sorted
                if (maxVal <= 0) return 100; 
                if (maxVal <= 2000) return Math.max(50, Math.round(maxVal / 20) /100)*100; // Finer ticks for smaller ranges
                return Math.max(100, Math.round(maxVal / 10000) * 1000) ; 
            };
            
            const layout = {
                title: `Levenshtein Distance Matrix: ${selectedChromName}`,
                xaxis: { 
                    title: `Position (kb)${transposeMatrixCheckbox.checked ? ' (Original Y)' : ''}`, 
                    dtick: makeDt_Tick(plotTrace.x), 
                    automargin: true,
                    // Ensure x-axis starts near 0 if data doesn't include it.
                    // range: plotTrace.x.length > 0 ? [Math.min(0, plotTrace.x[0]), plotTrace.x[plotTrace.x.length - 1]] : undefined
                },
                yaxis: { 
                    title: `Position (kb)${transposeMatrixCheckbox.checked ? ' (Original X)' : ''}`, 
                    autorange: 'reversed', 
                    dtick: makeDt_Tick(plotTrace.y), 
                    scaleanchor: fixedAspectRatioCheckbox.checked ? "x" : undefined, 
                    scaleratio: fixedAspectRatioCheckbox.checked ? 1 : undefined,
                    automargin: true,
                    // range: plotTrace.y.length > 0 ? [plotTrace.y[plotTrace.y.length - 1], Math.max(0, plotTrace.y[0])] : undefined // Reversed
                },
                margin: { l: 70, r: 40, b: 70, t: 70, pad: 5 }, autosize: true, 
                zmin: isNaN(zminUser) ? undefined : zminUser, zmax: isNaN(zmaxUser) ? undefined : zmaxUser,
            };
            
            Plotly.react(plotContainer, data, layout, {responsive: true});
            logStatus(`Plot updated for chromosome ${selectedChromName}.`);
        }

        function populateChromosomeSelect() { /* ... same ... */
            chromosomeSelect.innerHTML = ""; 
            if (transformedPlotDataCache && Object.keys(transformedPlotDataCache).length > 0) {
                Object.keys(transformedPlotDataCache).sort().forEach(chromName => {
                    const option = document.createElement('option'); option.value = chromName; option.textContent = chromName;
                    chromosomeSelect.appendChild(option);
                });
                chromosomeSelect.disabled = false; return true;
            } else {
                const option = document.createElement('option'); option.value = "";
                option.textContent = "No data processed"; chromosomeSelect.appendChild(option);
                chromosomeSelect.disabled = true; return false;
            }
        }
        
        // Main Processing Function
        async function handleProcessingRequest(isForVisualization) { /* ... same ... */
            if (!wasmInitialized) { const initSuccess = await initializeWasm(); if (!initSuccess) return; }
            if (!currentFastaBytes) { logStatus("No FASTA data staged. Please load data first."); return; }
            statusDiv.innerHTML = ""; logStatus(`Starting processing for ${isForVisualization ? 'visualization' : 'IPC download'}...`);
            spinnerContainer.classList.remove('hidden'); setUIDisabledState(true); 
            if (isForVisualization) { plotArea.classList.remove('hidden'); plotContainer.innerHTML = "Processing..."; transformedPlotDataCache = null; } 
            else { plotArea.classList.add('hidden'); }
            setTimeout(async () => {
                try {
                    if (isForVisualization) {
                        const jsonStringResult = process_fasta_to_plot_json(currentFastaBytes, currentIsGzipped, rustProgressCallback);
                        logStatus("Wasm (JSON) finished. Transforming data...");
                        if (!jsonStringResult) throw new Error("Wasm returned null/empty JSON.");
                        const jsonDataArray = JSON.parse(jsonStringResult);
                        transformedPlotDataCache = transformJsonToHeatmapCache(jsonDataArray);
                        if (transformedPlotDataCache && Object.keys(transformedPlotDataCache).length > 0 && populateChromosomeSelect()) { updatePlot(); } 
                        else { plotContainer.innerHTML = "No plottable data, or error in JSON transformation."; }
                    } else { 
                        const ipcOutputFileName = ipcFileNameInput.value.trim() || "distances.ipc";
                        logStatus(`Wasm (IPC) for ${ipcOutputFileName}...`);
                        const ipcBytesResult = process_fasta_to_ipc_bytes(currentFastaBytes, currentIsGzipped, rustProgressCallback);
                        logStatus("Wasm (IPC) finished."); const blob = new Blob([ipcBytesResult], { type: 'application/octet-stream' });
                        const downloadUrl = URL.createObjectURL(blob); const a = document.createElement('a');
                        a.href = downloadUrl; a.download = ipcOutputFileName; document.body.appendChild(a);
                        a.click(); document.body.removeChild(a); URL.revokeObjectURL(downloadUrl);
                        logStatus(`IPC data download as '${ipcOutputFileName}' initiated.`);
                    }
                } catch (error) { 
                    let errorMsg = `Error: ${error}`; if (error && error.message) { errorMsg += ` | Details: ${error.message}`; }
                    logStatus(errorMsg); console.error("Processing error:", error);
                    if (isForVisualization) plotContainer.innerHTML = "An error occurred.";
                } finally { spinnerContainer.classList.add('hidden'); setUIDisabledState(false); }
            }, 50);
        }

        // Event Listeners Setup
        function setupEventListeners() {
            fastaFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0]; if (file) stageFastaFromFile(file);
            });
            fetchUrlButton.addEventListener('click', stageFastaFromUrl);
            pasteButton.addEventListener('click', stageFastaFromText);  
            loadExampleButton.addEventListener('click', stageAndProcessExample); // This one auto-processes
            
            visualizeButton.addEventListener('click', () => handleProcessingRequest(true));
            downloadIpcButton.addEventListener('click', () => handleProcessingRequest(false));
            
            chromosomeSelect.addEventListener('change', updatePlot);
            colorscaleSelect.addEventListener('change', updatePlot);
            showColorbarCheckbox.addEventListener('change', updatePlot);
            reverseColorscaleCheckbox.addEventListener('change', updatePlot);
            zminInput.addEventListener('input', updatePlot); 
            zmaxInput.addEventListener('input', updatePlot);
            transposeMatrixCheckbox.addEventListener('change', updatePlot);
            cellGapRange.addEventListener('input', () => { // Update span and plot
                if (cellGapValueSpan) cellGapValueSpan.textContent = cellGapRange.value;
                updatePlot();
            });
            showTextOnCellsCheckbox.addEventListener('change', updatePlot);
            fixedAspectRatioCheckbox.addEventListener('change', updatePlot);


            const tabs = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    const targetTab = tab.getAttribute('data-tab');
                    tabContents.forEach(tc => { tc.classList.toggle('active', tc.id === targetTab); });
                    currentFastaBytes = null; updateActionButtonsState(); 
                    logStatus("Input method changed. Please provide new data for the active tab.");
                });
            });

            let resizeTimeout;
            window.addEventListener('resize', () => { 
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (transformedPlotDataCache && chromosomeSelect.value && transformedPlotDataCache[chromosomeSelect.value] && !plotArea.classList.contains('hidden')) {
                        updatePlot(); 
                    }
                }, 250); 
            });
        }

        // Page Load
        document.addEventListener('DOMContentLoaded', () => {
            initializeDOMReferences(); 
            setupEventListeners();     
            initializeWasm();          
            updateActionButtonsState(); 
            populateChromosomeSelect(); 
            if(cellGapRange && cellGapValueSpan) cellGapValueSpan.textContent = cellGapRange.value; // Init cell gap display
        });

    </script>
</body>
</html>
